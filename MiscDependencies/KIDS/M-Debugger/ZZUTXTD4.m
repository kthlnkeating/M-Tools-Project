ZZUTXTD4	;OAKLAND-OIFO/JLI-UNIT TESTS FOR XTDEBUG - CONTINUATION ;2/14/08  11:48
	;;7.3;TOOLKIT;**???**;Apr 25, 1995
	I $T(EN^XTMUNIT)'="" D UT ; RUNS UNIT TESTS WITH LOGGING TURNED ON
	Q
	;
UT	;
	K ^TMP("XTDEBUG2",$J),^TMP("XTDEBUG1",$J),^TMP("XTDEBUG3",$J)
	K ^TMP("XTDEBUG",$J),^TMP("XTDEBUG-S",$J)
	D INITEASY^XTMLOG("G,DEBUG-DATAX","DEBUG")
	D EN^XTMUNIT("ZZUTXTD4") ; 1")
	D ENDLOG^XTMLOG
	Q
	;
TAGPARTS	;
	N TAGVAL,RESULTS
	S TAGVAL="TESTENT+4^ZZUTXTD1(VAR1,VAR2)"
	D TAGPARTS^XTDEBUG(.RESULTS,TAGVAL)
	D CHKEQ^XTMUNIT(RESULTS("LINE"),"TESTENT+4","LINE value incorrect")
	D CHKEQ^XTMUNIT(RESULTS("ROUTINE"),"ZZUTXTD1","ROUTINE value incorrect")
	D CHKEQ^XTMUNIT(RESULTS("ARGS"),"VAR1,VAR2","ARGS value incorrect")
	Q
	;
COMMANDS	;
	N ZZUTGLOB,ZZUTLINE,X,Y,Z,RES,ZZUTVALS
	N XTDEBQUI,ZZLEVEL
	S ZZUTGLOB=$$GETGLOBS^XTDEBUG() K @ZZUTGLOB
	S ZZUTGLOB=$$GETGLOB^XTDEBUG() K @ZZUTGLOB
	S ZZUTLINE="S X=3,Y=4,Z=X+Y Q:X=3  S Y=1"
	S ZZUTLINE=$$GETCMND^XTDEBUG(.ZZUTVALS,ZZUTLINE)
	S @ZZUTGLOB@("LASTLVL")=1
	S @ZZUTGLOB@("EXITTYPE")="STEP"
	S @ZZUTGLOB@("LVL",1,"CMND")=ZZUTLINE
	K @ZZUTGLOB@("LVL",1,"XTDEBARG")
	M @ZZUTGLOB@("LVL",1,"XTDEBARG")=ZZUTVALS
	D STRTCMND^XTDEBUG ; step onto line and execute first command
	D INFO^XTMLOG("BACK FROM STRTCMND")
	D NEXT^XTDEBUG(.RES,"STEP")
	;
	D CHKEQ^XTMUNIT($G(X),3,"Bad value of X 1")
	D CHKEQ^XTMUNIT($G(Y),"","Bad value of Y 1")
	D CHKEQ^XTMUNIT($G(@ZZUTGLOB@("LVL",1,"ENTRY")),"COMMANDS^XTDEBUG","Didnt set up for re-entry")
	;
	D NEXT^XTDEBUG(.RES,"STEP")
	D INFO^XTMLOG("BACK FROM NEXT 1")
	D CHKEQ^XTMUNIT($G(X),3,"Bad value of X 2")
	D CHKEQ^XTMUNIT($G(Y),4,"Bad value of Y 2")
	D CHKEQ^XTMUNIT($G(Z),"","Bad value of Z 2")
	;
	D NEXT^XTDEBUG(.RES,"STEP")
	D INFO^XTMLOG("BACK FROM NEXT 2")
	D CHKEQ^XTMUNIT($G(X),3,"Bad value of X 3")
	D CHKEQ^XTMUNIT($G(Y),4,"Bad value of Y 3")
	D CHKEQ^XTMUNIT($G(Z),7,"Bad value of Z 3")
	;
	D NEXT^XTDEBUG(.RES,"STEP")
	D INFO^XTMLOG("BACK FROM NEXT 3")
	D CHKEQ^XTMUNIT($G(@ZZUTGLOB@("LVL",1,"ENTRY")),"","Didn't reset re-entry value")
	;
	S ZZUTLINE=$$GETCMND^XTDEBUG(.ZZUTVALS,ZZUTLINE)
	S ZZLEVEL=@ZZUTGLOB@("LASTLVL")
	S @ZZUTGLOB@("LVL",ZZLEVEL,"CMND")=ZZUTLINE
	K @ZZUTGLOB@("LVL",ZZLEVEL,"XTDEBARG")
	M @ZZUTGLOB@("LVL",ZZLEVEL,"XTDEBARG")=ZZUTVALS
	;
	D STRTCMND^XTDEBUG ;(.ZZUTVALS,ZZUTLINE)
	D NEXT^XTDEBUG(.RES,"STEP")
	D CHKEQ^XTMUNIT($G(@ZZUTGLOB@("LVL",ZZLEVEL,"CMND")),"S Y=1","Didn't clear rest of line")
	Q
	;
DOLINE	;
	N ZZUTLINE,X,Y,XTDEBLOC,XTDEBTYP
	S ZZUTLINE="S X=4,Y=3 D TESTENT^ZZUTXTD1(X,Y) F I=1:1:5 Q:I=3  S X=X+I ; COMMENT"
	S XTDEBLOC=$$GETGLOB^XTDEBUG() K @XTDEBLOC
	S XTDEBTYP="RUN"
	S @XTDEBLOC@("LASTLVL")=0
	S @XTDEBLOC@("LVL",0,"CMND")=ZZUTLINE
	S @XTDEBLOC@("LVL",0,"ROUTINE")="@",@XTDEBLOC@("LVL",0,"LINE")="" ;$$LINENUM^XTDEBUG("ZZUTXTD1","DOLINEA+1")
	Q
	D DOLINE^XTDEBUG
	Q
	D CHKEQ^XTMUNIT($G(X),7,"Return value was not expected value")
	; TODO - add tests for DLINEB
	Q
	;
DOLRDOLR	;
	N XTDEBLOC,XTNOARG,ZZUTLINE,XTDEBEN1,RESULTS,XVAL,RES
	S XTDEBLOC=$$GETGLOB^XTDEBUG() K @XTDEBLOC S XTNOARG=$$RESULTS^XTDEBUG()
	S ZZUTLINE="S XVAL=$$GETGLOB^XTDEBUG()"
	;S @XTDEBLOC@("LASTLVL")=0
	;S @XTDEBLOC@("LVL",0,"CMND")=ZZUTLINE
	;S @XTDEBLOC@("LVL",0,"ROUTINE")="@",@XTDEBLOC@("LVL",0,"LINE")="" ;$$LINENUM^XTDEBUG("ZZUTXTD1","DOLINEA+1")
	;S @XTDEBLOC@("EXITTYPE")="RUN",XTDEBEN1=1
	;D DOLINE^XTDEBUG
	D START^XTDEBUG(.RES,ZZUTLINE)
	D NEXT^XTDEBUG(.RES,"RUN")
	; D NEXT^XTDEBUG(.RES,"STEP") ; NEEDED IF STEP IS USED AS EXITTYPE
	; D NEXT^XTDEBUG(.RES,"STEP") ; NEEDED IF STEP IS USED AS EXITTYPE
	D CHKEQ^XTMUNIT($G(XVAL),"^TMP(""XTDEBUG"","_$J_")","1 Incorrect value")
	Q
	;
SETDOLR	;
	N XTDEBLOC,XTNOARG,ZZUTLINE,XTDEBEN1,XVAL,RES
	S XTDEBLOC=$$GETGLOB^XTDEBUG() K @XTDEBLOC S XTNOARG=$$RESULTS^XTDEBUG()
	S ZZUTLINE="S XVAL=$$FACTORIL^ZZUTXTD1(3)"
	;S @XTDEBLOC@("LASTLVL")=0
	;S @XTDEBLOC@("LVL",0,"CMND")=ZZUTLINE
	;S @XTDEBLOC@("LVL",0,"ROUTINE")="@",@XTDEBLOC@("LVL",0,"LINE")="" ;$$LINENUM^XTDEBUG("ZZUTXTD1","DOLINEA+1")
	;S @XTDEBLOC@("EXITTYPE")="",XTDEBEN1=1
	;D DOLINE^XTDEBUG
	D START^XTDEBUG(.RES,ZZUTLINE)
	D NEXT^XTDEBUG(.RES,"RUN")
	D CHKEQ^XTMUNIT($G(XVAL),6,"Incorrect value")
	;
	S ZZUTLINE="S XVAL=$$NOW^ZZUTXTD4()"
	D START^XTDEBUG(.RES,ZZUTLINE)
	D NEXT^XTDEBUG(.RES,"RUN")
	D CHKEQ(XVAL\1,$$NOW^ZZUTXTD4()\1,"Didn't return correct date value")
	;
	S ZZUTLINE="S XVAL=XVAL\1"
	D START^XTDEBUG(.RES,ZZUTLINE)
	D NEXT^XTDEBUG(.RES,"RUN")
	D CHKEQ(XVAL,$$NOW^ZZUTXTD4()\1,"Didn't return correct value from integer div")
	;
	S ZZUTLINE="S XVAL=$$NOW^ZZUTXTD4()\1"
	D START^XTDEBUG(.RES,ZZUTLINE)
	D NEXT^XTDEBUG(.RES,"RUN")
	D CHKEQ(XVAL,$$NOW^ZZUTXTD4()\1,"Didn't return value from function and integer div")
	;
	S ZZUTLINE="S XVAL=$$TSTDOLRS($$NOW^ZZUTXTD4()\1,1)"
	D START^XTDEBUG(.RES,ZZUTLINE)
	D NEXT^XTDEBUG(.RES,"RUN")
	D CHKEQ(XVAL,($$NOW^ZZUTXTD4()\1)+1,"Incorrect value from $$TSTDOLRS")
	Q
	;
NOW()	;
	Q 3070223.124
	;
DONOARG	; process argumentless DO command
	;N XTJLI ;S XTJLI=1
	N XTDEBLOC,XTNOARG,ZZLINNUM,RESULTS,ZZLVL
	S XTNOARG=$$RESULTS^XTDEBUG() K @XTNOARG
	S XTDEBLOC=$$GETGLOB^XTDEBUG() K @XTDEBLOC
	D START^XTDEBUG(.RESULTS,"D NOARG^ZZUTXTD1") ; ;
	S ZZLINNUM=$$LINENUM^XTDEBUG("ZZUTXTD1","NOARG")
	D NEXT^XTDEBUG(.RESULTS,"STEP")
	S ZZLVL=+@XTDEBLOC@("LASTLVL")
	D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LVL",ZZLVL,"XTDEBARG","CMND")),";","CMND value not expected")
	D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LVL",ZZLVL,"LINE")),ZZLINNUM,"Line Number not correct")
	; move into unargumented level, test functionality of SETNOARG
	K ^TMP("XTDEBUG2",$J)
	D NEXT^XTDEBUG(.RESULTS,"STEP") ; D  S
	; SETNOARG should increment the level
	S ZZLVL=+@XTDEBLOC@("LASTLVL")
	D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LVL",ZZLVL,"XTDEBARG","CMND")),"D","CMND value not expected")
	D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LVL",ZZLVL,"LINE")),ZZLINNUM+1,"Line Number not correct")
	;
	; execute the line
	D NEXT^XTDEBUG(.RESULTS,"STEP") ; . S
	D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LASTLVL")),2,"Wrong Level")
	S ZZLVL=+@XTDEBLOC@("LASTLVL")
	; and SETNOARG should set value of "NOARG" node to depth of DO's with NOARGs
	D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LVL",ZZLVL,"XTDEBARG","CMND")),"S","CMND value not expected")
	D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LVL",ZZLVL,"LINE")),ZZLINNUM+2,"Line Number not correct")
	;
	D NEXT^XTDEBUG(.RESULTS,"STEP") ; D S
	S ZZLVL=+@XTDEBLOC@("LASTLVL")
	D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LVL",ZZLVL,"XTDEBARG","CMND")),"S","CMND value not expected")
	D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LVL",ZZLVL,"LINE")),ZZLINNUM+1,"Line Number not correct")
	D CHKEQ^XTMUNIT($G(Y),1,"Y value not correct")
	;
	D NEXT^XTDEBUG(.RESULTS,"STEP")
	S ZZLVL=+@XTDEBLOC@("LASTLVL")
	D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LVL",ZZLVL,"XTDEBARG","CMND")),"Q","CMND value not expected")
	D CHKEQ^XTMUNIT($G(@XTDEBLOC@("LVL",ZZLVL,"LINE")),ZZLINNUM+3,"Line Number not correct")
	D CHKEQ^XTMUNIT($G(Y),1,"Final Y value not correct")
	D CHKEQ^XTMUNIT($G(X),3,"Final X value not correct")
	; needs to set proper starting line number
	D NEXT^XTDEBUG(.RESULTS,"STEP")
	Q
	;
DONOARG1	;
	N X,Y,Z,N,RESULTS,XTDEBLOC
	S X=0,Y=0,Z=0,N=0
	S XTDEBLOC=$$GETGLOB^XTDEBUG()
	D START^XTDEBUG(.RESULTS,"D NOARG1^ZZUTXTD1")
	D NEXT^XTDEBUG(.RESULTS,"RUN")
	;
	D CHKEQ^XTMUNIT($G(X),1,"Final X value not correct")
	D CHKEQ^XTMUNIT($G(Y),7,"Final X value not correct")
	D CHKEQ^XTMUNIT($G(Z),5,"Final X value not correct")
	D CHKEQ^XTMUNIT($G(N),4,"Final X value not correct")
	Q
	;
GETPERIO	;
	N ZZLINE,NPERIODS
	S ZZLINE="THIS LINE"
	S NPERIODS=$$GETPERIO^XTDEBUG(.ZZLINE)
	D CHKEQ^XTMUNIT(ZZLINE,"THIS LINE","Incorrect line returned for no periods")
	D CHKEQ^XTMUNIT(NPERIODS,0,"Incorrect number of periods for none there")
	;
	S ZZLINE=" . . . THIS LINE"
	S NPERIODS=$$GETPERIO^XTDEBUG(.ZZLINE)
	D CHKEQ^XTMUNIT(ZZLINE,"THIS LINE","Incorrect line returned for periods with spaces")
	D CHKEQ^XTMUNIT(NPERIODS,3,"Incorrect number of periods with spaces")
	;
	S ZZLINE="..THIS LINE"
	S NPERIODS=$$GETPERIO^XTDEBUG(.ZZLINE)
	D CHKEQ^XTMUNIT(ZZLINE,"THIS LINE","Incorrect line returned with no spaces")
	D CHKEQ^XTMUNIT(NPERIODS,2,"Incorrect number of periods with no spaces")
	Q
	;
DOLRSX	;
	N ZZLINE,X,Y,RES,XVALUE
	S ZZLINE="S X=$S(Y=1:3,1:0)"
	S Y=1
	D START^XTDEBUG(.RES,ZZLINE)
	D NEXT^XTDEBUG(.RES,"RUN")
	D CHKTF^XTMUNIT($G(X)=3,"Incorrect value from $S")
	;
	S Y=4
	D START^XTDEBUG(.RES,ZZLINE)
	D NEXT^XTDEBUG(.RES,"RUN")
	D CHKEQ^XTMUNIT($G(X),0,"Incorrect value from $S")
	;
DOLRS	;
	;N XTJLI S XTJLI=1
	N ZZLINE,YVALUE,RES,XVALUE,X
	S ZZLINE="S X=$$TSTDOLRS^ZZUTXTD4($S(YVALUE=1:3,1:0),3)"
	S YVALUE=1
	D START^XTDEBUG(.RES,ZZLINE)
	D NEXT^XTDEBUG(.RES,"RUN")
	D CHKEQ^XTMUNIT($G(X),6,"NOT CORRECT")
	;
	S YVALUE=0
	D START^XTDEBUG(.RES,ZZLINE)
	D NEXT^XTDEBUG(.RES,"RUN")
	D CHKEQ^XTMUNIT($G(X),3,"NOT CORRECT")
	;
	S ZZLINE="S XVALUE=$$TSTDOLRS^ZZUTXTD4(YVALUE,XVALUE)"
	S YVALUE=1,XVALUE=4,X=3,Y=1
	D START^XTDEBUG(.RES,ZZLINE)
	D NEXT^XTDEBUG(.RES,"RUN")
	D CHKEQ^XTMUNIT($G(XVALUE),5,"Incorrect value with $S as arg to function")
	;
	S YVALUE=0,XVALUE=4
	D START^XTDEBUG(.RES,ZZLINE)
	D NEXT^XTDEBUG(.RES,"RUN")
	D CHKEQ^XTMUNIT($G(XVALUE),4,"Incorrect value with $S as arg to function")
	Q
	;
TSTDOLRS(VALUE,VALUE1)	;
	Q VALUE+VALUE1
	;
PASBYREF	;
	N ZZLINE,X,RES
	S ZZLINE="S X=0 D TSTBYREF^ZZUTXTD4(X)"
	D START^XTDEBUG(.RES,ZZLINE)
	D NEXT^XTDEBUG(.RES,"RUN")
	D CHKTF^XTMUNIT(X=0,"Acts like pass by reference when it isn't")
	;
	S ZZLINE="S X=0 D TSTBYREF^ZZUTXTD4(.X)"
	D START^XTDEBUG(.RES,ZZLINE)
	D NEXT^XTDEBUG(.RES,"RUN")
	D CHKTF^XTMUNIT(X=4,"Pass by ref didn't affect value")
	D CHKTF^XTMUNIT($D(X)>1,"Pass by ref didn't return subscripted values")
	D CHKTF^XTMUNIT($G(X(3))=6,"Pass by ref didn't return correct subscript value")
	Q
	;
TSTBYREF(VALUE)	;
	; Q:VALUE=+VALUE
	; Q:$E(VALUE)'?1A
	S VALUE=4
	S VALUE(3)=6
	Q
	;
CHKARGS	;
	N ZZINPUT,ZZLINE,ZZXX
	S ZZLINE="X=Y*$$NOW^ZZUTXTD4()+$$TSTDOLRS($S(Y=3:1,1:0))-$$NOW^ZZUTXTD3+1"
	S ZZINPUT=ZZLINE
	S ZZXX=$$CHKARGS^XTDEBUG(.ZZINPUT)
	D CHKEQ(ZZXX,"S XTDEBV(4)=$$NOW^ZZUTXTD3 S XTDEBV(3)=$S(Y=3:1,1:0) S XTDEBV(2)=$$TSTDOLRS(XTDEBV(3)) S XTDEBV(1)=$$NOW^ZZUTXTD4()","BAD PRE-PROCESSING VALUES")
	D CHKEQ(ZZINPUT,"X=Y*XTDEBV(1)+XTDEBV(2)-XTDEBV(4)+1")
	Q
PREPROS	;
	N ZZLINE,XTDEBLOC,Y,X,XTDEBV
	S ZZLINE="S XTDEBV(4)=$$NOW,XTDEBV(3)=$S(Y=3:1,1:0),XTDEBV(2)=$$TSTDOLRS(XTDEBV(3),4),XTDEBV(1)=$$NOW^ZZUTXTD4()"
	S Y=3
	S XTDEBLOC=$$GETGLOB^XTDEBUG()
	S @XTDEBLOC@("LASTLVL")=0
	S @XTDEBLOC@("LVL",0,"ARGS","CURR")=3
	S @XTDEBLOC@("LVL",0,"CMND")="Q"
	S @XTDEBLOC@("LVL",0,"PRE-PROCESS")=ZZLINE
	S @XTDEBLOC@("LVL",0,"ROUTINE")="ZZUTXTD4"
	S @XTDEBLOC@("LVL",0,"XTDEBARG","ARGS",3)="X=Y*XTDEBV(1)+XTDEBV(2)-XTDEBV(4)+1"
	S @XTDEBLOC@("LVL",0,"XTDEBARG","CMND")="S"
	D PREPROCS^XTDEBUG
	D CHKTF^XTMUNIT(X=6140452.248,"Bad value returned from PREPROCS")
	Q
	;
CHKEQ(VAR1,VAR2,ERRMSG)	;
	D CHKEQ^XTMUNIT(VAR1,VAR2,$G(ERRMSG))
	Q
	;
CHKTF(VAR,ERRMSG)	;
	D CHKTF^XTMUNIT(VAR,$G(ERRMSG))
	Q
	;
XTROU	;
	;;ZZUTXTD1;
XTENT	;
	;;DOLRSX;simple $SELECT
	;;DOLRS;handle $SELECT
	;;PREPROS;PRE-PROCESSING OF $$ AND $S
	;;CHKARGS;check for arguments needing pre-processing
	;;PASBYREF;handle arguments passed by reference
	;;SETDOLR;various tests of functions
	;;DONOARG1;multiple argless DO commands
	;;GETPERIO;returns number of periods at start of line
	;;DONOARG;handle unargumented DO commands
	;;DOLINE;handle a line of code
	;;TAGPARTS;get individual parts of the TAG entry
	;;COMMANDS;handle various types of commands
	;;DOLRDOLR;handle intrinsic functions
